// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package handlers

//go:generate minimock -i github.com/alonsoF100/authorization-service/internal/transport/http/handlers.AuthService -o auth_service_mock_test.go -n AuthServiceMock -p handlers

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/alonsoF100/authorization-service/internal/models"
	"github.com/gojuno/minimock/v3"
)

// AuthServiceMock implements AuthService
type AuthServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcSignIn          func(ctx context.Context, email string, password string) (s1 string, err error)
	funcSignInOrigin    string
	inspectFuncSignIn   func(ctx context.Context, email string, password string)
	afterSignInCounter  uint64
	beforeSignInCounter uint64
	SignInMock          mAuthServiceMockSignIn

	funcSignUp          func(ctx context.Context, nickname string, email string, password string) (up1 *models.User, err error)
	funcSignUpOrigin    string
	inspectFuncSignUp   func(ctx context.Context, nickname string, email string, password string)
	afterSignUpCounter  uint64
	beforeSignUpCounter uint64
	SignUpMock          mAuthServiceMockSignUp

	funcValidateJWT          func(ctx context.Context, tokenString string) (cp1 *models.Claims, err error)
	funcValidateJWTOrigin    string
	inspectFuncValidateJWT   func(ctx context.Context, tokenString string)
	afterValidateJWTCounter  uint64
	beforeValidateJWTCounter uint64
	ValidateJWTMock          mAuthServiceMockValidateJWT
}

// NewAuthServiceMock returns a mock for AuthService
func NewAuthServiceMock(t minimock.Tester) *AuthServiceMock {
	m := &AuthServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SignInMock = mAuthServiceMockSignIn{mock: m}
	m.SignInMock.callArgs = []*AuthServiceMockSignInParams{}

	m.SignUpMock = mAuthServiceMockSignUp{mock: m}
	m.SignUpMock.callArgs = []*AuthServiceMockSignUpParams{}

	m.ValidateJWTMock = mAuthServiceMockValidateJWT{mock: m}
	m.ValidateJWTMock.callArgs = []*AuthServiceMockValidateJWTParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthServiceMockSignIn struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockSignInExpectation
	expectations       []*AuthServiceMockSignInExpectation

	callArgs []*AuthServiceMockSignInParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockSignInExpectation specifies expectation struct of the AuthService.SignIn
type AuthServiceMockSignInExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockSignInParams
	paramPtrs          *AuthServiceMockSignInParamPtrs
	expectationOrigins AuthServiceMockSignInExpectationOrigins
	results            *AuthServiceMockSignInResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockSignInParams contains parameters of the AuthService.SignIn
type AuthServiceMockSignInParams struct {
	ctx      context.Context
	email    string
	password string
}

// AuthServiceMockSignInParamPtrs contains pointers to parameters of the AuthService.SignIn
type AuthServiceMockSignInParamPtrs struct {
	ctx      *context.Context
	email    *string
	password *string
}

// AuthServiceMockSignInResults contains results of the AuthService.SignIn
type AuthServiceMockSignInResults struct {
	s1  string
	err error
}

// AuthServiceMockSignInOrigins contains origins of expectations of the AuthService.SignIn
type AuthServiceMockSignInExpectationOrigins struct {
	origin         string
	originCtx      string
	originEmail    string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSignIn *mAuthServiceMockSignIn) Optional() *mAuthServiceMockSignIn {
	mmSignIn.optional = true
	return mmSignIn
}

// Expect sets up expected params for AuthService.SignIn
func (mmSignIn *mAuthServiceMockSignIn) Expect(ctx context.Context, email string, password string) *mAuthServiceMockSignIn {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthServiceMockSignInExpectation{}
	}

	if mmSignIn.defaultExpectation.paramPtrs != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by ExpectParams functions")
	}

	mmSignIn.defaultExpectation.params = &AuthServiceMockSignInParams{ctx, email, password}
	mmSignIn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSignIn.expectations {
		if minimock.Equal(e.params, mmSignIn.defaultExpectation.params) {
			mmSignIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignIn.defaultExpectation.params)
		}
	}

	return mmSignIn
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.SignIn
func (mmSignIn *mAuthServiceMockSignIn) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockSignIn {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthServiceMockSignInExpectation{}
	}

	if mmSignIn.defaultExpectation.params != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by Expect")
	}

	if mmSignIn.defaultExpectation.paramPtrs == nil {
		mmSignIn.defaultExpectation.paramPtrs = &AuthServiceMockSignInParamPtrs{}
	}
	mmSignIn.defaultExpectation.paramPtrs.ctx = &ctx
	mmSignIn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSignIn
}

// ExpectEmailParam2 sets up expected param email for AuthService.SignIn
func (mmSignIn *mAuthServiceMockSignIn) ExpectEmailParam2(email string) *mAuthServiceMockSignIn {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthServiceMockSignInExpectation{}
	}

	if mmSignIn.defaultExpectation.params != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by Expect")
	}

	if mmSignIn.defaultExpectation.paramPtrs == nil {
		mmSignIn.defaultExpectation.paramPtrs = &AuthServiceMockSignInParamPtrs{}
	}
	mmSignIn.defaultExpectation.paramPtrs.email = &email
	mmSignIn.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmSignIn
}

// ExpectPasswordParam3 sets up expected param password for AuthService.SignIn
func (mmSignIn *mAuthServiceMockSignIn) ExpectPasswordParam3(password string) *mAuthServiceMockSignIn {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthServiceMockSignInExpectation{}
	}

	if mmSignIn.defaultExpectation.params != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by Expect")
	}

	if mmSignIn.defaultExpectation.paramPtrs == nil {
		mmSignIn.defaultExpectation.paramPtrs = &AuthServiceMockSignInParamPtrs{}
	}
	mmSignIn.defaultExpectation.paramPtrs.password = &password
	mmSignIn.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmSignIn
}

// Inspect accepts an inspector function that has same arguments as the AuthService.SignIn
func (mmSignIn *mAuthServiceMockSignIn) Inspect(f func(ctx context.Context, email string, password string)) *mAuthServiceMockSignIn {
	if mmSignIn.mock.inspectFuncSignIn != nil {
		mmSignIn.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.SignIn")
	}

	mmSignIn.mock.inspectFuncSignIn = f

	return mmSignIn
}

// Return sets up results that will be returned by AuthService.SignIn
func (mmSignIn *mAuthServiceMockSignIn) Return(s1 string, err error) *AuthServiceMock {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthServiceMockSignInExpectation{mock: mmSignIn.mock}
	}
	mmSignIn.defaultExpectation.results = &AuthServiceMockSignInResults{s1, err}
	mmSignIn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSignIn.mock
}

// Set uses given function f to mock the AuthService.SignIn method
func (mmSignIn *mAuthServiceMockSignIn) Set(f func(ctx context.Context, email string, password string) (s1 string, err error)) *AuthServiceMock {
	if mmSignIn.defaultExpectation != nil {
		mmSignIn.mock.t.Fatalf("Default expectation is already set for the AuthService.SignIn method")
	}

	if len(mmSignIn.expectations) > 0 {
		mmSignIn.mock.t.Fatalf("Some expectations are already set for the AuthService.SignIn method")
	}

	mmSignIn.mock.funcSignIn = f
	mmSignIn.mock.funcSignInOrigin = minimock.CallerInfo(1)
	return mmSignIn.mock
}

// When sets expectation for the AuthService.SignIn which will trigger the result defined by the following
// Then helper
func (mmSignIn *mAuthServiceMockSignIn) When(ctx context.Context, email string, password string) *AuthServiceMockSignInExpectation {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthServiceMock.SignIn mock is already set by Set")
	}

	expectation := &AuthServiceMockSignInExpectation{
		mock:               mmSignIn.mock,
		params:             &AuthServiceMockSignInParams{ctx, email, password},
		expectationOrigins: AuthServiceMockSignInExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSignIn.expectations = append(mmSignIn.expectations, expectation)
	return expectation
}

// Then sets up AuthService.SignIn return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockSignInExpectation) Then(s1 string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockSignInResults{s1, err}
	return e.mock
}

// Times sets number of times AuthService.SignIn should be invoked
func (mmSignIn *mAuthServiceMockSignIn) Times(n uint64) *mAuthServiceMockSignIn {
	if n == 0 {
		mmSignIn.mock.t.Fatalf("Times of AuthServiceMock.SignIn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSignIn.expectedInvocations, n)
	mmSignIn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSignIn
}

func (mmSignIn *mAuthServiceMockSignIn) invocationsDone() bool {
	if len(mmSignIn.expectations) == 0 && mmSignIn.defaultExpectation == nil && mmSignIn.mock.funcSignIn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSignIn.mock.afterSignInCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSignIn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SignIn implements AuthService
func (mmSignIn *AuthServiceMock) SignIn(ctx context.Context, email string, password string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSignIn.beforeSignInCounter, 1)
	defer mm_atomic.AddUint64(&mmSignIn.afterSignInCounter, 1)

	mmSignIn.t.Helper()

	if mmSignIn.inspectFuncSignIn != nil {
		mmSignIn.inspectFuncSignIn(ctx, email, password)
	}

	mm_params := AuthServiceMockSignInParams{ctx, email, password}

	// Record call args
	mmSignIn.SignInMock.mutex.Lock()
	mmSignIn.SignInMock.callArgs = append(mmSignIn.SignInMock.callArgs, &mm_params)
	mmSignIn.SignInMock.mutex.Unlock()

	for _, e := range mmSignIn.SignInMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSignIn.SignInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignIn.SignInMock.defaultExpectation.Counter, 1)
		mm_want := mmSignIn.SignInMock.defaultExpectation.params
		mm_want_ptrs := mmSignIn.SignInMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockSignInParams{ctx, email, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSignIn.t.Errorf("AuthServiceMock.SignIn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignIn.SignInMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmSignIn.t.Errorf("AuthServiceMock.SignIn got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignIn.SignInMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmSignIn.t.Errorf("AuthServiceMock.SignIn got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignIn.SignInMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignIn.t.Errorf("AuthServiceMock.SignIn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSignIn.SignInMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignIn.SignInMock.defaultExpectation.results
		if mm_results == nil {
			mmSignIn.t.Fatal("No results are set for the AuthServiceMock.SignIn")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSignIn.funcSignIn != nil {
		return mmSignIn.funcSignIn(ctx, email, password)
	}
	mmSignIn.t.Fatalf("Unexpected call to AuthServiceMock.SignIn. %v %v %v", ctx, email, password)
	return
}

// SignInAfterCounter returns a count of finished AuthServiceMock.SignIn invocations
func (mmSignIn *AuthServiceMock) SignInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignIn.afterSignInCounter)
}

// SignInBeforeCounter returns a count of AuthServiceMock.SignIn invocations
func (mmSignIn *AuthServiceMock) SignInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignIn.beforeSignInCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.SignIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignIn *mAuthServiceMockSignIn) Calls() []*AuthServiceMockSignInParams {
	mmSignIn.mutex.RLock()

	argCopy := make([]*AuthServiceMockSignInParams, len(mmSignIn.callArgs))
	copy(argCopy, mmSignIn.callArgs)

	mmSignIn.mutex.RUnlock()

	return argCopy
}

// MinimockSignInDone returns true if the count of the SignIn invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockSignInDone() bool {
	if m.SignInMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SignInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SignInMock.invocationsDone()
}

// MinimockSignInInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockSignInInspect() {
	for _, e := range m.SignInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.SignIn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSignInCounter := mm_atomic.LoadUint64(&m.afterSignInCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SignInMock.defaultExpectation != nil && afterSignInCounter < 1 {
		if m.SignInMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.SignIn at\n%s", m.SignInMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.SignIn at\n%s with params: %#v", m.SignInMock.defaultExpectation.expectationOrigins.origin, *m.SignInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignIn != nil && afterSignInCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.SignIn at\n%s", m.funcSignInOrigin)
	}

	if !m.SignInMock.invocationsDone() && afterSignInCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.SignIn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SignInMock.expectedInvocations), m.SignInMock.expectedInvocationsOrigin, afterSignInCounter)
	}
}

type mAuthServiceMockSignUp struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockSignUpExpectation
	expectations       []*AuthServiceMockSignUpExpectation

	callArgs []*AuthServiceMockSignUpParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockSignUpExpectation specifies expectation struct of the AuthService.SignUp
type AuthServiceMockSignUpExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockSignUpParams
	paramPtrs          *AuthServiceMockSignUpParamPtrs
	expectationOrigins AuthServiceMockSignUpExpectationOrigins
	results            *AuthServiceMockSignUpResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockSignUpParams contains parameters of the AuthService.SignUp
type AuthServiceMockSignUpParams struct {
	ctx      context.Context
	nickname string
	email    string
	password string
}

// AuthServiceMockSignUpParamPtrs contains pointers to parameters of the AuthService.SignUp
type AuthServiceMockSignUpParamPtrs struct {
	ctx      *context.Context
	nickname *string
	email    *string
	password *string
}

// AuthServiceMockSignUpResults contains results of the AuthService.SignUp
type AuthServiceMockSignUpResults struct {
	up1 *models.User
	err error
}

// AuthServiceMockSignUpOrigins contains origins of expectations of the AuthService.SignUp
type AuthServiceMockSignUpExpectationOrigins struct {
	origin         string
	originCtx      string
	originNickname string
	originEmail    string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSignUp *mAuthServiceMockSignUp) Optional() *mAuthServiceMockSignUp {
	mmSignUp.optional = true
	return mmSignUp
}

// Expect sets up expected params for AuthService.SignUp
func (mmSignUp *mAuthServiceMockSignUp) Expect(ctx context.Context, nickname string, email string, password string) *mAuthServiceMockSignUp {
	if mmSignUp.mock.funcSignUp != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Set")
	}

	if mmSignUp.defaultExpectation == nil {
		mmSignUp.defaultExpectation = &AuthServiceMockSignUpExpectation{}
	}

	if mmSignUp.defaultExpectation.paramPtrs != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by ExpectParams functions")
	}

	mmSignUp.defaultExpectation.params = &AuthServiceMockSignUpParams{ctx, nickname, email, password}
	mmSignUp.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSignUp.expectations {
		if minimock.Equal(e.params, mmSignUp.defaultExpectation.params) {
			mmSignUp.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignUp.defaultExpectation.params)
		}
	}

	return mmSignUp
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.SignUp
func (mmSignUp *mAuthServiceMockSignUp) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockSignUp {
	if mmSignUp.mock.funcSignUp != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Set")
	}

	if mmSignUp.defaultExpectation == nil {
		mmSignUp.defaultExpectation = &AuthServiceMockSignUpExpectation{}
	}

	if mmSignUp.defaultExpectation.params != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Expect")
	}

	if mmSignUp.defaultExpectation.paramPtrs == nil {
		mmSignUp.defaultExpectation.paramPtrs = &AuthServiceMockSignUpParamPtrs{}
	}
	mmSignUp.defaultExpectation.paramPtrs.ctx = &ctx
	mmSignUp.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSignUp
}

// ExpectNicknameParam2 sets up expected param nickname for AuthService.SignUp
func (mmSignUp *mAuthServiceMockSignUp) ExpectNicknameParam2(nickname string) *mAuthServiceMockSignUp {
	if mmSignUp.mock.funcSignUp != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Set")
	}

	if mmSignUp.defaultExpectation == nil {
		mmSignUp.defaultExpectation = &AuthServiceMockSignUpExpectation{}
	}

	if mmSignUp.defaultExpectation.params != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Expect")
	}

	if mmSignUp.defaultExpectation.paramPtrs == nil {
		mmSignUp.defaultExpectation.paramPtrs = &AuthServiceMockSignUpParamPtrs{}
	}
	mmSignUp.defaultExpectation.paramPtrs.nickname = &nickname
	mmSignUp.defaultExpectation.expectationOrigins.originNickname = minimock.CallerInfo(1)

	return mmSignUp
}

// ExpectEmailParam3 sets up expected param email for AuthService.SignUp
func (mmSignUp *mAuthServiceMockSignUp) ExpectEmailParam3(email string) *mAuthServiceMockSignUp {
	if mmSignUp.mock.funcSignUp != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Set")
	}

	if mmSignUp.defaultExpectation == nil {
		mmSignUp.defaultExpectation = &AuthServiceMockSignUpExpectation{}
	}

	if mmSignUp.defaultExpectation.params != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Expect")
	}

	if mmSignUp.defaultExpectation.paramPtrs == nil {
		mmSignUp.defaultExpectation.paramPtrs = &AuthServiceMockSignUpParamPtrs{}
	}
	mmSignUp.defaultExpectation.paramPtrs.email = &email
	mmSignUp.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmSignUp
}

// ExpectPasswordParam4 sets up expected param password for AuthService.SignUp
func (mmSignUp *mAuthServiceMockSignUp) ExpectPasswordParam4(password string) *mAuthServiceMockSignUp {
	if mmSignUp.mock.funcSignUp != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Set")
	}

	if mmSignUp.defaultExpectation == nil {
		mmSignUp.defaultExpectation = &AuthServiceMockSignUpExpectation{}
	}

	if mmSignUp.defaultExpectation.params != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Expect")
	}

	if mmSignUp.defaultExpectation.paramPtrs == nil {
		mmSignUp.defaultExpectation.paramPtrs = &AuthServiceMockSignUpParamPtrs{}
	}
	mmSignUp.defaultExpectation.paramPtrs.password = &password
	mmSignUp.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmSignUp
}

// Inspect accepts an inspector function that has same arguments as the AuthService.SignUp
func (mmSignUp *mAuthServiceMockSignUp) Inspect(f func(ctx context.Context, nickname string, email string, password string)) *mAuthServiceMockSignUp {
	if mmSignUp.mock.inspectFuncSignUp != nil {
		mmSignUp.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.SignUp")
	}

	mmSignUp.mock.inspectFuncSignUp = f

	return mmSignUp
}

// Return sets up results that will be returned by AuthService.SignUp
func (mmSignUp *mAuthServiceMockSignUp) Return(up1 *models.User, err error) *AuthServiceMock {
	if mmSignUp.mock.funcSignUp != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Set")
	}

	if mmSignUp.defaultExpectation == nil {
		mmSignUp.defaultExpectation = &AuthServiceMockSignUpExpectation{mock: mmSignUp.mock}
	}
	mmSignUp.defaultExpectation.results = &AuthServiceMockSignUpResults{up1, err}
	mmSignUp.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSignUp.mock
}

// Set uses given function f to mock the AuthService.SignUp method
func (mmSignUp *mAuthServiceMockSignUp) Set(f func(ctx context.Context, nickname string, email string, password string) (up1 *models.User, err error)) *AuthServiceMock {
	if mmSignUp.defaultExpectation != nil {
		mmSignUp.mock.t.Fatalf("Default expectation is already set for the AuthService.SignUp method")
	}

	if len(mmSignUp.expectations) > 0 {
		mmSignUp.mock.t.Fatalf("Some expectations are already set for the AuthService.SignUp method")
	}

	mmSignUp.mock.funcSignUp = f
	mmSignUp.mock.funcSignUpOrigin = minimock.CallerInfo(1)
	return mmSignUp.mock
}

// When sets expectation for the AuthService.SignUp which will trigger the result defined by the following
// Then helper
func (mmSignUp *mAuthServiceMockSignUp) When(ctx context.Context, nickname string, email string, password string) *AuthServiceMockSignUpExpectation {
	if mmSignUp.mock.funcSignUp != nil {
		mmSignUp.mock.t.Fatalf("AuthServiceMock.SignUp mock is already set by Set")
	}

	expectation := &AuthServiceMockSignUpExpectation{
		mock:               mmSignUp.mock,
		params:             &AuthServiceMockSignUpParams{ctx, nickname, email, password},
		expectationOrigins: AuthServiceMockSignUpExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSignUp.expectations = append(mmSignUp.expectations, expectation)
	return expectation
}

// Then sets up AuthService.SignUp return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockSignUpExpectation) Then(up1 *models.User, err error) *AuthServiceMock {
	e.results = &AuthServiceMockSignUpResults{up1, err}
	return e.mock
}

// Times sets number of times AuthService.SignUp should be invoked
func (mmSignUp *mAuthServiceMockSignUp) Times(n uint64) *mAuthServiceMockSignUp {
	if n == 0 {
		mmSignUp.mock.t.Fatalf("Times of AuthServiceMock.SignUp mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSignUp.expectedInvocations, n)
	mmSignUp.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSignUp
}

func (mmSignUp *mAuthServiceMockSignUp) invocationsDone() bool {
	if len(mmSignUp.expectations) == 0 && mmSignUp.defaultExpectation == nil && mmSignUp.mock.funcSignUp == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSignUp.mock.afterSignUpCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSignUp.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SignUp implements AuthService
func (mmSignUp *AuthServiceMock) SignUp(ctx context.Context, nickname string, email string, password string) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmSignUp.beforeSignUpCounter, 1)
	defer mm_atomic.AddUint64(&mmSignUp.afterSignUpCounter, 1)

	mmSignUp.t.Helper()

	if mmSignUp.inspectFuncSignUp != nil {
		mmSignUp.inspectFuncSignUp(ctx, nickname, email, password)
	}

	mm_params := AuthServiceMockSignUpParams{ctx, nickname, email, password}

	// Record call args
	mmSignUp.SignUpMock.mutex.Lock()
	mmSignUp.SignUpMock.callArgs = append(mmSignUp.SignUpMock.callArgs, &mm_params)
	mmSignUp.SignUpMock.mutex.Unlock()

	for _, e := range mmSignUp.SignUpMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmSignUp.SignUpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignUp.SignUpMock.defaultExpectation.Counter, 1)
		mm_want := mmSignUp.SignUpMock.defaultExpectation.params
		mm_want_ptrs := mmSignUp.SignUpMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockSignUpParams{ctx, nickname, email, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSignUp.t.Errorf("AuthServiceMock.SignUp got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignUp.SignUpMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.nickname != nil && !minimock.Equal(*mm_want_ptrs.nickname, mm_got.nickname) {
				mmSignUp.t.Errorf("AuthServiceMock.SignUp got unexpected parameter nickname, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignUp.SignUpMock.defaultExpectation.expectationOrigins.originNickname, *mm_want_ptrs.nickname, mm_got.nickname, minimock.Diff(*mm_want_ptrs.nickname, mm_got.nickname))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmSignUp.t.Errorf("AuthServiceMock.SignUp got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignUp.SignUpMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmSignUp.t.Errorf("AuthServiceMock.SignUp got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignUp.SignUpMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignUp.t.Errorf("AuthServiceMock.SignUp got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSignUp.SignUpMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignUp.SignUpMock.defaultExpectation.results
		if mm_results == nil {
			mmSignUp.t.Fatal("No results are set for the AuthServiceMock.SignUp")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmSignUp.funcSignUp != nil {
		return mmSignUp.funcSignUp(ctx, nickname, email, password)
	}
	mmSignUp.t.Fatalf("Unexpected call to AuthServiceMock.SignUp. %v %v %v %v", ctx, nickname, email, password)
	return
}

// SignUpAfterCounter returns a count of finished AuthServiceMock.SignUp invocations
func (mmSignUp *AuthServiceMock) SignUpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignUp.afterSignUpCounter)
}

// SignUpBeforeCounter returns a count of AuthServiceMock.SignUp invocations
func (mmSignUp *AuthServiceMock) SignUpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignUp.beforeSignUpCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.SignUp.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignUp *mAuthServiceMockSignUp) Calls() []*AuthServiceMockSignUpParams {
	mmSignUp.mutex.RLock()

	argCopy := make([]*AuthServiceMockSignUpParams, len(mmSignUp.callArgs))
	copy(argCopy, mmSignUp.callArgs)

	mmSignUp.mutex.RUnlock()

	return argCopy
}

// MinimockSignUpDone returns true if the count of the SignUp invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockSignUpDone() bool {
	if m.SignUpMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SignUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SignUpMock.invocationsDone()
}

// MinimockSignUpInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockSignUpInspect() {
	for _, e := range m.SignUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.SignUp at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSignUpCounter := mm_atomic.LoadUint64(&m.afterSignUpCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SignUpMock.defaultExpectation != nil && afterSignUpCounter < 1 {
		if m.SignUpMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.SignUp at\n%s", m.SignUpMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.SignUp at\n%s with params: %#v", m.SignUpMock.defaultExpectation.expectationOrigins.origin, *m.SignUpMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignUp != nil && afterSignUpCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.SignUp at\n%s", m.funcSignUpOrigin)
	}

	if !m.SignUpMock.invocationsDone() && afterSignUpCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.SignUp at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SignUpMock.expectedInvocations), m.SignUpMock.expectedInvocationsOrigin, afterSignUpCounter)
	}
}

type mAuthServiceMockValidateJWT struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockValidateJWTExpectation
	expectations       []*AuthServiceMockValidateJWTExpectation

	callArgs []*AuthServiceMockValidateJWTParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockValidateJWTExpectation specifies expectation struct of the AuthService.ValidateJWT
type AuthServiceMockValidateJWTExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockValidateJWTParams
	paramPtrs          *AuthServiceMockValidateJWTParamPtrs
	expectationOrigins AuthServiceMockValidateJWTExpectationOrigins
	results            *AuthServiceMockValidateJWTResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockValidateJWTParams contains parameters of the AuthService.ValidateJWT
type AuthServiceMockValidateJWTParams struct {
	ctx         context.Context
	tokenString string
}

// AuthServiceMockValidateJWTParamPtrs contains pointers to parameters of the AuthService.ValidateJWT
type AuthServiceMockValidateJWTParamPtrs struct {
	ctx         *context.Context
	tokenString *string
}

// AuthServiceMockValidateJWTResults contains results of the AuthService.ValidateJWT
type AuthServiceMockValidateJWTResults struct {
	cp1 *models.Claims
	err error
}

// AuthServiceMockValidateJWTOrigins contains origins of expectations of the AuthService.ValidateJWT
type AuthServiceMockValidateJWTExpectationOrigins struct {
	origin            string
	originCtx         string
	originTokenString string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateJWT *mAuthServiceMockValidateJWT) Optional() *mAuthServiceMockValidateJWT {
	mmValidateJWT.optional = true
	return mmValidateJWT
}

// Expect sets up expected params for AuthService.ValidateJWT
func (mmValidateJWT *mAuthServiceMockValidateJWT) Expect(ctx context.Context, tokenString string) *mAuthServiceMockValidateJWT {
	if mmValidateJWT.mock.funcValidateJWT != nil {
		mmValidateJWT.mock.t.Fatalf("AuthServiceMock.ValidateJWT mock is already set by Set")
	}

	if mmValidateJWT.defaultExpectation == nil {
		mmValidateJWT.defaultExpectation = &AuthServiceMockValidateJWTExpectation{}
	}

	if mmValidateJWT.defaultExpectation.paramPtrs != nil {
		mmValidateJWT.mock.t.Fatalf("AuthServiceMock.ValidateJWT mock is already set by ExpectParams functions")
	}

	mmValidateJWT.defaultExpectation.params = &AuthServiceMockValidateJWTParams{ctx, tokenString}
	mmValidateJWT.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmValidateJWT.expectations {
		if minimock.Equal(e.params, mmValidateJWT.defaultExpectation.params) {
			mmValidateJWT.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateJWT.defaultExpectation.params)
		}
	}

	return mmValidateJWT
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.ValidateJWT
func (mmValidateJWT *mAuthServiceMockValidateJWT) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockValidateJWT {
	if mmValidateJWT.mock.funcValidateJWT != nil {
		mmValidateJWT.mock.t.Fatalf("AuthServiceMock.ValidateJWT mock is already set by Set")
	}

	if mmValidateJWT.defaultExpectation == nil {
		mmValidateJWT.defaultExpectation = &AuthServiceMockValidateJWTExpectation{}
	}

	if mmValidateJWT.defaultExpectation.params != nil {
		mmValidateJWT.mock.t.Fatalf("AuthServiceMock.ValidateJWT mock is already set by Expect")
	}

	if mmValidateJWT.defaultExpectation.paramPtrs == nil {
		mmValidateJWT.defaultExpectation.paramPtrs = &AuthServiceMockValidateJWTParamPtrs{}
	}
	mmValidateJWT.defaultExpectation.paramPtrs.ctx = &ctx
	mmValidateJWT.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmValidateJWT
}

// ExpectTokenStringParam2 sets up expected param tokenString for AuthService.ValidateJWT
func (mmValidateJWT *mAuthServiceMockValidateJWT) ExpectTokenStringParam2(tokenString string) *mAuthServiceMockValidateJWT {
	if mmValidateJWT.mock.funcValidateJWT != nil {
		mmValidateJWT.mock.t.Fatalf("AuthServiceMock.ValidateJWT mock is already set by Set")
	}

	if mmValidateJWT.defaultExpectation == nil {
		mmValidateJWT.defaultExpectation = &AuthServiceMockValidateJWTExpectation{}
	}

	if mmValidateJWT.defaultExpectation.params != nil {
		mmValidateJWT.mock.t.Fatalf("AuthServiceMock.ValidateJWT mock is already set by Expect")
	}

	if mmValidateJWT.defaultExpectation.paramPtrs == nil {
		mmValidateJWT.defaultExpectation.paramPtrs = &AuthServiceMockValidateJWTParamPtrs{}
	}
	mmValidateJWT.defaultExpectation.paramPtrs.tokenString = &tokenString
	mmValidateJWT.defaultExpectation.expectationOrigins.originTokenString = minimock.CallerInfo(1)

	return mmValidateJWT
}

// Inspect accepts an inspector function that has same arguments as the AuthService.ValidateJWT
func (mmValidateJWT *mAuthServiceMockValidateJWT) Inspect(f func(ctx context.Context, tokenString string)) *mAuthServiceMockValidateJWT {
	if mmValidateJWT.mock.inspectFuncValidateJWT != nil {
		mmValidateJWT.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.ValidateJWT")
	}

	mmValidateJWT.mock.inspectFuncValidateJWT = f

	return mmValidateJWT
}

// Return sets up results that will be returned by AuthService.ValidateJWT
func (mmValidateJWT *mAuthServiceMockValidateJWT) Return(cp1 *models.Claims, err error) *AuthServiceMock {
	if mmValidateJWT.mock.funcValidateJWT != nil {
		mmValidateJWT.mock.t.Fatalf("AuthServiceMock.ValidateJWT mock is already set by Set")
	}

	if mmValidateJWT.defaultExpectation == nil {
		mmValidateJWT.defaultExpectation = &AuthServiceMockValidateJWTExpectation{mock: mmValidateJWT.mock}
	}
	mmValidateJWT.defaultExpectation.results = &AuthServiceMockValidateJWTResults{cp1, err}
	mmValidateJWT.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmValidateJWT.mock
}

// Set uses given function f to mock the AuthService.ValidateJWT method
func (mmValidateJWT *mAuthServiceMockValidateJWT) Set(f func(ctx context.Context, tokenString string) (cp1 *models.Claims, err error)) *AuthServiceMock {
	if mmValidateJWT.defaultExpectation != nil {
		mmValidateJWT.mock.t.Fatalf("Default expectation is already set for the AuthService.ValidateJWT method")
	}

	if len(mmValidateJWT.expectations) > 0 {
		mmValidateJWT.mock.t.Fatalf("Some expectations are already set for the AuthService.ValidateJWT method")
	}

	mmValidateJWT.mock.funcValidateJWT = f
	mmValidateJWT.mock.funcValidateJWTOrigin = minimock.CallerInfo(1)
	return mmValidateJWT.mock
}

// When sets expectation for the AuthService.ValidateJWT which will trigger the result defined by the following
// Then helper
func (mmValidateJWT *mAuthServiceMockValidateJWT) When(ctx context.Context, tokenString string) *AuthServiceMockValidateJWTExpectation {
	if mmValidateJWT.mock.funcValidateJWT != nil {
		mmValidateJWT.mock.t.Fatalf("AuthServiceMock.ValidateJWT mock is already set by Set")
	}

	expectation := &AuthServiceMockValidateJWTExpectation{
		mock:               mmValidateJWT.mock,
		params:             &AuthServiceMockValidateJWTParams{ctx, tokenString},
		expectationOrigins: AuthServiceMockValidateJWTExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmValidateJWT.expectations = append(mmValidateJWT.expectations, expectation)
	return expectation
}

// Then sets up AuthService.ValidateJWT return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockValidateJWTExpectation) Then(cp1 *models.Claims, err error) *AuthServiceMock {
	e.results = &AuthServiceMockValidateJWTResults{cp1, err}
	return e.mock
}

// Times sets number of times AuthService.ValidateJWT should be invoked
func (mmValidateJWT *mAuthServiceMockValidateJWT) Times(n uint64) *mAuthServiceMockValidateJWT {
	if n == 0 {
		mmValidateJWT.mock.t.Fatalf("Times of AuthServiceMock.ValidateJWT mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateJWT.expectedInvocations, n)
	mmValidateJWT.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmValidateJWT
}

func (mmValidateJWT *mAuthServiceMockValidateJWT) invocationsDone() bool {
	if len(mmValidateJWT.expectations) == 0 && mmValidateJWT.defaultExpectation == nil && mmValidateJWT.mock.funcValidateJWT == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateJWT.mock.afterValidateJWTCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateJWT.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateJWT implements AuthService
func (mmValidateJWT *AuthServiceMock) ValidateJWT(ctx context.Context, tokenString string) (cp1 *models.Claims, err error) {
	mm_atomic.AddUint64(&mmValidateJWT.beforeValidateJWTCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateJWT.afterValidateJWTCounter, 1)

	mmValidateJWT.t.Helper()

	if mmValidateJWT.inspectFuncValidateJWT != nil {
		mmValidateJWT.inspectFuncValidateJWT(ctx, tokenString)
	}

	mm_params := AuthServiceMockValidateJWTParams{ctx, tokenString}

	// Record call args
	mmValidateJWT.ValidateJWTMock.mutex.Lock()
	mmValidateJWT.ValidateJWTMock.callArgs = append(mmValidateJWT.ValidateJWTMock.callArgs, &mm_params)
	mmValidateJWT.ValidateJWTMock.mutex.Unlock()

	for _, e := range mmValidateJWT.ValidateJWTMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmValidateJWT.ValidateJWTMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateJWT.ValidateJWTMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateJWT.ValidateJWTMock.defaultExpectation.params
		mm_want_ptrs := mmValidateJWT.ValidateJWTMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockValidateJWTParams{ctx, tokenString}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmValidateJWT.t.Errorf("AuthServiceMock.ValidateJWT got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateJWT.ValidateJWTMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tokenString != nil && !minimock.Equal(*mm_want_ptrs.tokenString, mm_got.tokenString) {
				mmValidateJWT.t.Errorf("AuthServiceMock.ValidateJWT got unexpected parameter tokenString, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmValidateJWT.ValidateJWTMock.defaultExpectation.expectationOrigins.originTokenString, *mm_want_ptrs.tokenString, mm_got.tokenString, minimock.Diff(*mm_want_ptrs.tokenString, mm_got.tokenString))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateJWT.t.Errorf("AuthServiceMock.ValidateJWT got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmValidateJWT.ValidateJWTMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateJWT.ValidateJWTMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateJWT.t.Fatal("No results are set for the AuthServiceMock.ValidateJWT")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmValidateJWT.funcValidateJWT != nil {
		return mmValidateJWT.funcValidateJWT(ctx, tokenString)
	}
	mmValidateJWT.t.Fatalf("Unexpected call to AuthServiceMock.ValidateJWT. %v %v", ctx, tokenString)
	return
}

// ValidateJWTAfterCounter returns a count of finished AuthServiceMock.ValidateJWT invocations
func (mmValidateJWT *AuthServiceMock) ValidateJWTAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateJWT.afterValidateJWTCounter)
}

// ValidateJWTBeforeCounter returns a count of AuthServiceMock.ValidateJWT invocations
func (mmValidateJWT *AuthServiceMock) ValidateJWTBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateJWT.beforeValidateJWTCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.ValidateJWT.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateJWT *mAuthServiceMockValidateJWT) Calls() []*AuthServiceMockValidateJWTParams {
	mmValidateJWT.mutex.RLock()

	argCopy := make([]*AuthServiceMockValidateJWTParams, len(mmValidateJWT.callArgs))
	copy(argCopy, mmValidateJWT.callArgs)

	mmValidateJWT.mutex.RUnlock()

	return argCopy
}

// MinimockValidateJWTDone returns true if the count of the ValidateJWT invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockValidateJWTDone() bool {
	if m.ValidateJWTMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateJWTMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateJWTMock.invocationsDone()
}

// MinimockValidateJWTInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockValidateJWTInspect() {
	for _, e := range m.ValidateJWTMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.ValidateJWT at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterValidateJWTCounter := mm_atomic.LoadUint64(&m.afterValidateJWTCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateJWTMock.defaultExpectation != nil && afterValidateJWTCounter < 1 {
		if m.ValidateJWTMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.ValidateJWT at\n%s", m.ValidateJWTMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.ValidateJWT at\n%s with params: %#v", m.ValidateJWTMock.defaultExpectation.expectationOrigins.origin, *m.ValidateJWTMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateJWT != nil && afterValidateJWTCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.ValidateJWT at\n%s", m.funcValidateJWTOrigin)
	}

	if !m.ValidateJWTMock.invocationsDone() && afterValidateJWTCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.ValidateJWT at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateJWTMock.expectedInvocations), m.ValidateJWTMock.expectedInvocationsOrigin, afterValidateJWTCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockSignInInspect()

			m.MinimockSignUpInspect()

			m.MinimockValidateJWTInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSignInDone() &&
		m.MinimockSignUpDone() &&
		m.MinimockValidateJWTDone()
}
